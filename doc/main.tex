\documentclass[12pt]{article}
\usepackage[letterpaper, margin=1in]{geometry}
\usepackage{amsmath}
\usepackage{amssymb}
\usepackage{listings}
\usepackage{enumitem}
\usepackage{parskip}
\usepackage{graphicx}
\usepackage{physics}
\newcommand{\Lagr}{\mathcal{L}}
\newcommand{\pderiv}[2]{\frac{\partial #1}{\partial #2}}
\newcommand{\vv}[2]{\vec{#1}_\text{#2}}
\newcommand{\powt}[2]{#1 \times 10^{#2}}
\newcommand{\eigbasis}[0]{[\Phi_j]}

\title{QDynamics internal documentation}
\author{Duncan M. Freeman}

\begin{document}
\maketitle
DISCLAIMER: THIS IS A WORK IN PROGRESS PROJECT AND MAKES NO CLAIM OF SCIENTIFIC VALUE OR ACCURACY OF ANY KIND. DO NOT RELY ON THIS WORK!

With that out of the way, welcome!

This is documentation for my own purposes, to remember how this all fits together.

This project is a basic mockup of the Fewest Switches Surface Hopping
Method, and follows:

Pedagogical Overview of the Fewest Switches Surface Hopping Method
Amber Jain and Aarti Sindhu
ACS Omega 2022 7 (50), 45810-45824
DOI: 10.1021/acsomega.2c04843

(todo: actual citation lol)
\clearpage

\subsection{Overview}
The algorithm works like this:

1. Initialize runtime parameters:
\begin{itemize}
    \item $(R, P)$: These are the position and momentum vectors of the atomic nuclei. They are modelled clasically. In code, they are called position and velocity, the mass being assumed constant for all nuclei.
    \item $\lambda$: The current electronic state we are allowing the nuclei to observe. The corresponding energy eigenstate will be denoted $\Phi_\lambda$.
    \item $c_j$: The current electronic wavefunction parameters. It can also be represented as a vector $\vec{c}$. Note that $\psi(t)$ is a linear combination of energy eigenstates based on these coefficients: 
        \[ \psi(t=0) = \eigbasis \vec{c} \]

        Or, in another notation, parameterized by time:
        \[ \ket{\psi(t)} = \sum_j e^{-iE_jt/\hbar} c_j \ket{\Phi_j} \]

        This may be obtained by a delta function in energy space (setting an element of $c_j$ to one), or by obtaining eigenvectors and solving for the coefficients given a desired wavefunction input ($\eigbasis^{-1} \psi_0 = \vec{c}$ ).
\end{itemize}

(Main loop begins here)

2. Calculate new energy eigenbasis
\begin{itemize}
    \item Recalculate energy eigenbasis; $H\Phi_j = E_j\Phi_j$.

        Make sure to solve the old one for calculations futher down the line!

        Use an SVD algorithm to get $\Phi_j$ from $H$ (eigenbasis in matrix representation hereby represented as $\eigbasis$).

        Note that if $\bra{\Phi_j(t - \Delta T)}\ket{\Phi_j(t)} < 0$, we should set $\ket{\Phi_j(t)} = -\ket{\Phi_j(t)}$.
\end{itemize}

3. Integrate classical motion using quantum-derived forces
\begin{itemize}
    \item Calculate the force on the protons due to (single component $\lambda$ of) the electron cloud and proton-proton interaction.
        \[ m\ddot{R} = F = -\bra{\Phi_\lambda}\nabla_R H\ket{\Phi_\lambda} \]

    \item Integrate proton motion by a small time step.
\end{itemize}

\clearpage
4. Integrate quantum equations of motion
\[ V_{kj} = \bra{\Phi_k}H\ket{\Phi_j} \]
\[ U_{kj} = \bra{\Phi_k(t_0)}H\ket{\Phi_j(t_0 + dt_c)} \]
\[ T_{kj} = \frac{1}{dt_c}\log(U) \]
\[ \dot{c}_j = -\frac{i}{\hbar} \sum_j (V_{kj} - i\hbar T_{kj})c_j \]

5. Calculate potential surface hopping probability
\[ P(\lambda\to k) = \frac{2\Re(T_{\lambda k} c_\lambda^* c_k)}{|c_\lambda|^2} \]

Call a random number $r$ between 0 and 1. If $\sum_{l=1}^{k-1} P(\lambda\to k) < r < \sum_{l=1}^k P(\lambda\to k)$, then we will hop to this new state $k$.  

6. Handling a hop

Calculate the derivative coupling vector:


Determine the coefficient $\gamma$ to conserve total energy.

5. Display to user

5. Goto 2

\subsection{Basis}


\end{document}

